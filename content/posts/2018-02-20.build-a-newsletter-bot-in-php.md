---
title: Build a newsletter chatbot in PHP - Part 1
category: chatbots
summary: Email has been a great channel for staying in touch with your audience for years. But times are changing and messengers are taking over communication. Let's see how I used Facebook Messenger to build a little newsletter bot for my upcoming book "Build Chatbots with PHP".
---

## What book?

Since the beginning of the year, I am working on a new project of mine. It's a book called [Build Chatbots with PHP](https://christoph-rumpel.com/build-chatbots-with-php). Follow the link to find out what it is about and who it is for.
<br /><br />
More interesting to us is the newsletter, to which you can subscribe on the book's website. About once or twice a month I will send out an email with news on the development of the book. That's a common approach. I can spread the word about my product and you can get the latest news. In my case, you also get a discount for the upcoming book and a free sample chapter.

## Messengers to the rescue

In the sample chapter, I explain how messengers trigger a big shift right now. They have become the communication channel number one for so many people and started the rise of the chatbots. It is of great interest to a lot of users to receive information directly inside their favorite messenger. This makes sense, because they already spend a lot of their time there.
<br /><br />This is why `chatbots play a such a big role right now`. They can bring `automated services to every chat`. We want to use that for our newsletter as well. So instead of sending a traditional email, you can keep your users updated on a messenger. This is what we are going to do now.

## The plan

So here is the plan. Next, to the traditional newsletter subscription we want to provide another option, that works with a messenger; Facebook Messenger in this case. Facebook has a nice [Customer Chat Plugin](https://developers.facebook.com/docs/messenger-platform/discovery/customer-chat-plugin) that we can integrate into the landing page. This way the users don't have to leave the landing page while subscribing. This plugin makes it possible for the user to chat with our Facebook Messenger Bot without leaving the page. Awesome, right?
<br /><br />
Here is what we are going to do:

* BotMan setup
* Facebook setup
* Test it
* The sign up process
* Storing subscriptions
* Extras
* Sending newsletters
* BotMan Tests

## BotMan setup

The easiest way to install BotMan Studio is via the installer. (Skip this, if you got it already installed)

```bash
composer global require "botman/installer"
```

After that, you can install a new instance like and change directory:

```bash
botman new newsletter-bot && cd newsletter-bot
```

Inside the new directory, we then need to install the Facebook driver. Luckily there is a nice command for that as well.

```bash
php artisan botman:install-driver facebook
```

In order to connect our BotMan application to a Facebook app, we need to define some environment values. Copy these to you `.env` file. Later we will change the values to the correct ones.

```bash
FACEBOOK_TOKEN=YOUR_APP_FACEBOOK_PAGE_TOKEN
FACEBOOK_APP_SECRET=YOUR_APP_SECRET
FACEBOOK_VERIFICATION=YOUR_VERIFICATION
```

Ok, so last step here is to make our application publicly available. I use Laravel valet for that. It provides a little command to create a temporary public URL to the local application. But you can also use tools like [ngrok](https://ngrok.com/) or an already deployed application URL. 

```bash
valet share
```


## Facebook setup

I won't cover how to create a Facebook Page or Facebook App here. Check [Build a Facebook Messenger chatbot in Laravel with BotMan Studio 2.0](https://christoph-rumpel.com/2017/09/build-a-facebook-chatbot-with-laravel-and-botman-studio/) or [Build a PHP chatbot in 10 minutes](https://christoph-rumpel.com/2016/08/build-a-php-chatbot-in-10-minutes/) to get more information about that.
<br /><br />
Now go to your Facebook App and grab the tokens. You can find the `App Secret` on the main dashboard. The other two are listed on the Messenger settings page. With `FACEBOOK_TOKEN` BotMan refers to the Facebook Page Access Token. You need to select the Facebook Page in order to get this token.
<br /><br />
Now we are ready to connect the BotMan instance with the Facebook app. Go to the "Webhooks" section inside your Messenger settings. There you can add the webhook. It is the URL where our BotMan application gets the messages from Facebook. Make sure to check the permissions for `messages` and `messaging_postback` in order to make it work. In this section, you also have to subscribe to a Facebook page.

<img class="blogimage"  alt="Screenshot showing how to subscribe to a Facebook page" src="/images/blog/blog_subscribe_fb_page.png" width="700" />

<div class="blognote"><strong>Note:</strong> If you get any errors, take look at my webhook debugging article <a href="https://christoph-rumpel.com/2017/09/botman-quick-tip-how-to-debug-facebook-webhook-errors">here</a>.</div>

## Test it

To make sure that everything has been setup correctly, let's try it out. Go to your Facebook Page and open the chat. When you send `Hi`, you should get back a reply from your bot. This is one of the given BotMan examples that works out of the box.

<img class="blogimage"  alt="Screenshot showing a message and a reply in Facebook Messenger." src="/images/blog/blog_test_hi.png" width="700" />

<br /><br />
If it doesn't reply, please check your `storage/logs/laravel.log` file for errors.

## The sign up process

Let's think about what the bot should be capable of again. When the user enters the chat, we want to send him a welcome message and information about the subscription. It should be possible to subscribe and unsubscribe from our messages. That's enough for this first version.

### Welcome message

In Facebook Messenger, there is the concept of a `get_started button`. When you add it, the user will see this button before he can enter the chat the first time. This way our application knows when a user enters the chat for the first time and we can react to that. In BotMan Studio we can add the button with a simple command.

```bash
php artisan botman:facebookAddStartButton
```

This will send a HTTP request to Facebook and active our button. You cannot change the text of the button, but the payload, which is sent to our application. You can define it in your `config/botman/facebook.php` file.

```php
/*
|--------------------------------------------------------------------------
| Facebook Start Button Payload
|--------------------------------------------------------------------------
|
| The payload which is sent when the Get Started Button is clicked.
|
*/
'start_button_payload' => 'GET_STARTED',
```
<div class="blognote"><strong>Note:</strong> After editing the payload value you need to use the artisan command again.</div>

The `payload` is what we can listen for in our BotMan route.

```php
$botman->hears('GET_STARTED', function (BotMan $bot) {
    $bot->reply('Welcome!');
});
```

In order to test a get_started button after the first visit, you need to delete the conversation. Then the button will appear again, the next time you enter the conversation.

<img class="blogimage" alt="Screenshot showing how to delete a Facebook Messenger conversation" src="/images/blog/fb_delete_conversation.png" />

Our bot should now welcome you with a little message.

### Make it a conversation

In BotMan a conversation class is a place where you can group questions that belong to each other. Let's create one for our subscription conversation.

```bash
php artisan botman:make:conversation SubscribeConversation
```

You can find this new class here: `/app/Http/Conversations/SubscribeConversation.php`

I always start my conversations with thinking about the different questions.

```php
<?php

namespace App\Http\Conversations;

use BotMan\BotMan\Messages\Conversations\Conversation;

class SubscribeConversation extends Conversation
{
    public function run()
    {
        $this->welcome();
    }

    private function welcome()
    {
    }

    private function askAboutSubscription()
    {
    }

}
```

The `run` method will be called first when you start a conversation. Here we define where to go next. First, we will welcome the user with a message and then we'll ask about the subscription. You could do that in one method too, but I like it better that way. There is also another reason. I already know that I want to use this conversation, even if the user is not visiting the bot the first time. So the welcome message only makes sense the first time.
<br ><br />
In the welcome method, we want to welcome the user (what a surprise) and trigger the subscription question. There we ask the user if he or she is ok with getting news from time to time about my book.

```php
private function welcome()
{
    $this->bot->reply('Hey and welcome! 👋');
    $this->askAboutSubscription();
}

private function askAboutSubscription()
{
    $this->bot->reply('I help Christoph to spread some news about his book development. 📘');
    $this->bot->reply('If you like, I can keep you updated about it here on Facebook Messenger.');

    $question = Question::create('Are you in?')
        ->addButtons([
            Button::create('Yes please')
                ->value('yes'),
            Button::create('Nope')
                ->value('no'),
        ]);

    $this->ask($question, function (Answer $answer) {
        if ($answer->getValue() === 'yes') {
            $this->bot->reply('Wuhu, great to have you on board! 🎉');
            $this->bot->reply('I will message you when there is something new to tell ✌️');
        } else {
            $this->bot->reply('Ok no problem. If change your mind, just type "subscribe".');
        }

        $this->bot->reply("Christoph also likes to blog a lot. Make sure to checkout his site for more chatbot stuff: \n ✨ https://christoph-rumpel.com/ ✨ ");
        $this->bot->reply('See you! 👋');
    });
}
```

It is quite some code, but nothing special here. Take some minutes to read it over and try it out yourself in the chat. You should see the welcome message, the question about the subscription and two options for responding to the answer. Both ways the user also gets a little bye-message with a note about my blog articles.

### Make it reusable 

Right now our conversation only works the when the user starts it with the get_started button. As mentioned in the reply messages, we want the bot to listen for the the "subscribe" keyword as well. Let's add that to our BotMan route.

```php
$botman->hears('GET_STARTED|subscribe', function (BotMan $bot) {
    $userFromStartButton = $bot->getMessage()->getText() === 'GET_STARTED' ? true : false;
    $bot->startConversation(new SubscribeConversation($userFromStartButton));
});
```
Next to the "GET_STARTED" text, we also listen for "subscribe". Both trigger the same action. But as you can see we are adding a boolean to our class constructor. This way we know inside our conversation class, if the user triggered the button or the text message.
<br /><br />
In our conversation we know have the chance to only show the welcome message, if it is a new user. To make this possible we need to add a constructor and a class property to check for.

```php
public function __construct(bool $userFromStartButton) {

    $this->userFromStartButton = $userFromStartButton;
}

public function run()
{
    $this->userFromStartButton ? $this->welcome() : $this->askAboutSubscription();
}
```

Now we can trigger the subscribe conversation with the text "subscribe" as well. This way the user is able to unsubscribe if needed.

## Storing subscriptions

You probably have noticed that we aren't storing any user information yet. Yes, you're right :-) So let's do that.
We can edit the already given user migration file `database/migrations/..._create_users_table.php` and add the accessible Facebook user data. Depending on the user's permissions, not all values are accessible. We make this values `nullable`.

```php
public function up()
{
    Schema::create('users', function (Blueprint $table) {
        $table->increments('id');
        $table->string('fb_id');
        $table->string('first_name');
        $table->string('last_name');
        $table->string('profile_pic')->nullable();
        $table->string('locale', 8)->nullable();
        $table->string('gender')->nullable();
        $table->boolean('subscribed')->default(false);
        $table->timestamps();
    });
}
```

Now create the table with `php artisan migrate`. 

<div class="blognote"><strong>Note:</strong> Make sure you have setup your database already before.</div>

With that done, we need a place where we add the users. For this purpose, I'd like to use a BotMan middleware. Like a Laravel middleware, it lets us perform tasks at certain points of the request cycle. For all incoming messages, I want to add or update a user. We can use the BotMan `Heard Middleware` for that. It will be called every time a message was matched.
<br /><br />Here is the code.

```php
<?php

namespace App\Http\Middleware;

use App\User;
use BotMan\BotMan\BotMan;
use BotMan\BotMan\Interfaces\Middleware\Heard;
use BotMan\BotMan\Messages\Incoming\IncomingMessage;

class SaveUserMiddleware implements Heard
{
    public function heard(IncomingMessage $message, $next, BotMan $bot)
    {
        $user = $bot->getUser();

        if($user instanceof \BotMan\Drivers\Facebook\Extensions\User) {
            User::createFromIncomingMessage($user);
        }

        return $next($message);
    }
}
```

Inside the `heard` method we grab the BotMan user object and put it inside a method from our user model. We need to check if the message is from Facebook Messenger. To accomplish it we could check the matched BotMan driver or, like we did, check the user object. Every driver has their own user class.
<br /><br />
And in the user model, we update or create the user.

```php
public static function createFromIncomingMessage(\BotMan\Drivers\Facebook\Extensions\User $user)
{
    User::updateOrCreate(['fb_id' => $user->getId()], [
		'fb_id' => $user->getId(),
		'first_name' => $user->getFirstName(),
		'last_name' => $user->getLastName(),
		'profile_pic' => $user->getProfilePic(),
		'locale' => $user->getLocale(),
		'gender' => $user->getGender(),
	]);
}
```
Give it a try. Type "subscribe" in the chat and with a little luck, you should get a reply and new user entry in your database. If not, check your logs for errors. If your app is responding to Facebook with a 500 error, make sure to uncomment the lines responsible for it immediately. This is important because Facebook will send, in case of an error, the message again and again. The sooner your application responds with a 200 code, the better it is. You can debug afterwards.

<div class="blognote"><strong>Note:</strong> Facebook sometimes blocks your app for several minutes if it receives too many errors from your application.</div>

Now that we have the users in our database we want to be able to subscribe and unsubscribe them. I will use two more user model methods for this purpose.

```php
/**
 * Subscribe user to newsletter
 *
 * @param string $facebookId
 */
public static function subscribe(string $facebookId)
{
    $user = User::where('fb_id', $facebookId)
        ->first();

    if ($user) {
        $user->subscribed = true;
        $user->save();
    }
}

/**
 * Unsubscribe user from newsletter
 *
 * @param string $facebookId
 */
public static function unsubscribe(string $facebookId)
{
    $user = User::where('fb_id', $facebookId)
        ->first();

    if ($user) {
        $user->subscribed = false;
        $user->save();
    }
}
```

Nothing special here. We are just checking to see if the user exists and then change the subscription boolean. We can now add those methods to our subscription conversation.

```php
if ($answer->getValue() === 'yes') {
    User::subscribe($answer->getMessage()->getSender());
    $this->bot->reply('Wuhu, great to have you on board! 🎉');
    $this->bot->reply('I will message you when there is something new to tell ✌️');
} else {
    User::unsubscribe($answer->getMessage()->getSender());
    $this->bot->reply('Ok no problem. If change your mind, just type "subscribe".');
}
```

And again please try it out yourself. When you subscribe, you should see that in the user table in your database.

## Extras

### Typing indicator
Essentially, we are almost done. Just two more things I want to add. First, you have probably noticed that the bo's messages pop in very fast. This is a problem when your text gets longer and the user needs more time to read. Additionally, in Facebook, there is a `typing indicator` which you probably already know. It shows some animated bubbles that tell you that the other chat member is typing right now. This is possible with bots as well with the `typesAndWaits` method in BotMan. It shows the typing indicator and waits for the desired time before moving on. This is exactly what we need.
<br /><br />
These are the conversation methods with the new additions:

```php
private function welcome()
{
    $this->bot->typesAndWaits(.5);
    $this->bot->reply('Hey and welcome! 👋');

    $this->askAboutSubscription();
}

private function askAboutSubscription()
{
    $this->bot->typesAndWaits(.5);
    $this->bot->reply('I help Christoph to spread some news about his book development. 📘');
    $this->bot->typesAndWaits(1);
    $this->bot->reply('If you like, I can keep you updated about it here on Facebook Messenger.');
    $this->bot->typesAndWaits(1);

    $question = Question::create('Are you in?')
        ->addButtons([
            Button::create('Yes please')
                ->value('yes'),
            Button::create('Nope')
                ->value('no'),
        ]);

    $this->ask($question, function (Answer $answer) {
        if ($answer->getValue() === 'yes') {
            User::subscribe($answer->getMessage()->getSender());
            $this->bot->reply('Wuhu, great to have you on board! 🎉');
            $this->bot->typesAndWaits(.5);
            $this->bot->reply('I will message you when there is something new to tell ✌️');
            $this->bot->typesAndWaits(.5);
        } else {
            User::unsubscribe($answer->getMessage()->getSender());
            $this->bot->typesAndWaits(1);
            $this->bot->reply('Ok no problem. If change your mind, just type "subscribe".');
        }

        $this->bot->typesAndWaits(1);
        $this->bot->reply("Christoph also likes to blog a lot. Make sure to checkout his site for more chatbot stuff: \n ✨ https://christoph-rumpel.com/ ✨ ");
        $this->bot->typesAndWaits(1);
        $this->bot->reply('See you! 👋');
    });
}
```

### Fallback

Another great little BotMan feature is the `fallback` method. For all incoming messages, that don't match your listeners, you can define some actions as well. I like to tell the user about what the bot can in order to help him with the next steps.

```php
$botman->fallback(function(BotMan $bot) {
    $bot->reply('Hey!');
    $bot->typesAndWaits(1);
    $bot->reply('I see those words of yours, but I have no idea what they mean. 🤔');
    $bot->typesAndWaits(1);
    $bot->reply('Christoph said I need to focus on telling you about his book development for now. Maybe later he will train me to understand your messages as well. I hope so ☺️');

    $bot->typesAndWaits(1);

    $question = ButtonTemplate::create('Here is how I can help you:')->addButtons([
       ElementButton::create('💌 Edit subscription')->type('postback')->payload('subscribe'),
       ElementButton::create('👉 Christoph\'s Blog')->url('https://christoph-rumpel.com/')
    ]);

    $bot->reply($question);

});
```

Don't just reply with `Sorry I don't understand your message.`. Give the user opportunities and help to move one. In my case, I tell them how to edit their subscription and where they can find more chatbot stuff of mine.

## Sending newsletters

### Requirements

Until now, we got everything set up to welcome users and to sign them in. Obviously, we are not done yet. We also want to send the users little messages about my book from time to time. It is no problem to send messages to users when they start a conversation with your bot. But sending replies, 24 hours after the last conversation, is not allowed. You must apply for the `pages_messaging_subscriptions` permission, to make that possible. Go to your Messenger settings and submit you Facebook App for another review, including pages_messaging_subscriptions.

<div class="blognote"><strong>Note:</strong> Find more details on the process <a href="https://developers.facebook.com/docs/messenger-platform/policy/policy-overview#subscription_messaging">here</a>.</div>

### Originating messages

Normally, this is the message flow: The user sends something, the bot replies. This is the same with the `get_started` button on Facebook. Here the button triggers the first "message", to which the bot replies. But with our newsletter bot, we want the bot to make the first step. In BotMan terms, this is called `originating messages`. This is an example of the BotMan documentation.

```php
$botman->say('Message', 'my-recipient-user-id', TelegramDriver::class);
```

It looks very similar to what we already know. The only difference is, that we provide the `say` method with a user ID and a driver name. I like to create a Laravel command and to place this code there. It gives me more freedom on how to trigger the message later, like with a cronjob.

```bash
php artisan make:command SendOutNewsletter
```

This creates a new command class in `/app/Console/Commands/`. There we can define a signature and a description.

```php
protected $signature = 'newsletter:send';

protected $description = 'Send newsletter to all subscribers';
```

The description you will see when you list all the artisan commands. The signature defines the command to run this code. In our case, it will be `php artisan newsletter:send`. But first, we need to place our code in the `handle` method.
```php
public function handle()
{
    // init botman
    $botman = app('botman');

    $users = User::where('subscribed', true)->get();

    $users->each(function ($user) use ($botman){
        try {
            $botman->say('Hey ' .$user->first_name.' ...', $user->fb_id, FacebookDriver::class);
        } catch (\Exception $e) {
            $this->info('FAIL sending message to '.$user->fb_id);
            $this->info($e->getCode().': '.$e->getMessage());
        }
    });

    $this->info('Success.');
}
```

First, the botman instance is resolved from the service container. Then we grab all the subscribed users from the database, in order to loop over them. We now send each user a message. The content is totally up to you of course. You can send just one message or multiple ones with different templates as well. For this example, one message is enough. You probably also noticed that we can personalize the messages with the name from the user table.

<div class="blognote"><strong>Note:</strong> It is important to only provide helpful content to the user when originating messages. We don't want to create another spam channel here.</div>

## BotMan Tests

As good PHP developers we always think about good ways to test our application in order to sleep better at night. The sames goes for chatbots. We haven't written any test yet. Especially when building chatbots is still new to you, I think it is better to concentrate on the implementation first. But I don't want to leave you without creating any tests. This is why we will add some basic tests now.
<br /><br />
Actually testing chatbots is quite different from other web applications. With chats we have lots of conversations and text to test. When the user says this, we assert that reply and so on. Let's start with the fallback test.

## Fallback Test

Under `tests/BotMan` you will find a basic BotMan example test. Here you can see how we test a chatbot. First we define the message the bot receives and then we set what we expect as reply. Copy the example test file and name the file and class `FallbackTest`. Remove the given test and replace it with this:
```php
/**
 * @return void
 * @test
 */
public function it_triggers_the_fallback_message()
{
	$this->bot->receives('What is your name?')
		->assertReply('Hey!')
		->assertReply('I see those words of yours, but I have no idea what they mean. 🤔')
		->assertReply('Christoph said I need to focus on telling you about his book development for now. Maybe later he will train me to understand your messages as well. I hope so ☺️');

	$template = ButtonTemplate::create('Here is how I can help you:')->addButtons([
		ElementButton::create('💌 Edit subscription')->type('postback')->payload('subscribe'),
		ElementButton::create('👉 Christoph\'s Blog')->url('https://christoph-rumpel.com/')
	]);

	$this->bot->assertTemplate($template, true);
}
```

The bot doesn't know what `What is your name?` means. We haven't implemented it yet, so the fallback message is triggered. Since we return multiple messages in the fallback method, we can also check for multiple ones. This is why we can use multiple `assertReply` methods. This is great for basic test messages. But for template messages we need to check the template with `assertTemplate`. Now run the test.

<img class="blogimage" alt="Screenshot showing the result of the Fallback test" src="/images/blog/nl_fallback_test.png" />

Everything should be green.

## Subscription Conversation Test

Now we move on the subscription process. Create another test file name it `SubscribeConversationTest.php`. We will create three tests here. First one, is for the welcome message.

```php
/**
 * @test
 */
public function it_welcomes_user_at_start()
{
	$this->bot->receives('GET_STARTED')
		->assertReply('Hey and welcome! 👋')
		->assertReply('I help Christoph to spread some news about his book development. 📘');
}
```

The bot receives the get_started button payload `GET_STARTED` and we assert two replies. Essentially, the bot sends more than these two replies. But for this test, it's just fine. I want to keep this test as simple as possible. Besides, we can trigger the other messages with the `subscribe` keyword as well. First we take care of the subscribe process with a positive answer.

```php
/**
 * @test
 **/
public function it_subscribes_a_user()
{
	$this->bot->receives('subscribe')
		->assertReply('I help Christoph to spread some news about his book development. 📘')
		->assertReply('If you like, I can keep you updated about it here on Facebook Messenger.')
		->assertQuestion('Are you in?')
		->receives('yes')
		->assertReply('Woohoo, great to have you on board! 🎉')
		->assertReply('I will message you when there is something new to tell ✌️')
		->assertReply("Christoph also likes to blog a lot. Make sure to check out his site for more chatbot stuff: \n ✨ https://christoph-rumpel.com/ ✨ ")
		->assertReply('See you! 👋');
}
```
Here we listen for the subscribe message, then assert some messages as well as a question. Additionally, we chain another incoming user message and assert the rest of the replies. `yes` is the value of our `Yes please` button. We can just use it as a trigger for the other messages. In order to test the negative reply, let's create another test.

```php
/**
 * @test
 **/
public function it_unsubscribes_a_user()
{
	$this->bot->receives('subscribe')
		->assertReply('I help Christoph to spread some news about his book development. 📘')
		->assertReply('If you like, I can keep you updated about it here on Facebook Messenger.')
		->assertQuestion('Are you in?')
		->receives('no')
		->assertReply('Ok no problem. If change your mind, just type "subscribe".')
		->assertReply("Christoph also likes to blog a lot. Make sure to check out his site for more chatbot stuff: \n ✨ https://christoph-rumpel.com/ ✨ ")
		->assertReply('See you! 👋');
}
```

It's basically the same, just with the users's negative response and our replies for this case. Now, run the tests again and everything should be green as well.

<img class="blogimage" alt="Screenshot showing the result of the subscription conversation test" src="/images/blog/nl_subscription_test.png" />

As you have probably noticed, we had to duplicate the beginning of the subscribe conversation. This is something that bothers me a lot and I am already figuring out with Marcel how to create a better solution. Still, these few tests are very helpful and good examples.

## Conclusion

We are done! Wow, that was quite a long article. I'm glad I could show you a new and real chatbot use case of mine. We covered everything from planning the bot to implementing and testing it. I hope you enjoyed this tutorial and it helps you for your next messenger newsletter. Visit me on [Twitter](https://twitter.com/christophrumpel) and let me know what you think about it. See you!